#!/bin/sh
exec guile --no-auto-compile -e '(@ (scripts update) main)' -s "$0" "$@"
!#

(define-module (scripts update)
  #:use-module (guile)
  #:use-module (guix build utils)
  #:use-module (guix http-client)
  #:use-module (guix import elpa)
  #:use-module (guix packages)
  #:use-module (ice-9 match)
  #:use-module (ice-9 pretty-print)
  #:use-module (ice-9 threads)
  #:use-module (ice-9 textual-ports)
  #:use-module (json)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (srfi srfi-11)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-43)
  #:use-module (web uri)
  #:export (main))

(define-record-type <archive-entry>
  (make-archive name raw-name version deps)
  archive?
  (name archive-name)
  (raw-name archive-raw-name)
  (version archive-version)
  (deps archive-deps set-archive-deps!))

(define (with-silent-out thunk)
  (let ((void-port (%make-void-port "w"))
	(result #f))
    (with-output-to-port void-port
      (lambda ()
	(with-error-to-port void-port
	  (lambda ()
	    (set! result (thunk))))))
    (close-port void-port)
    result))

(define (list-car-index key list)
  (list-index (lambda (c) (eq? (car c) key)) list))

(define emacs-standard-library?
  (let ((libs
	 (cons* "emacs"
		"cl-lib"
		(with-input-from-file (string-append (dirname (or (current-filename) "./update")) "/emacs-libs")
		  (lambda ()
		    (remove string-null?
			    (string-split (get-string-all (current-input-port))
					  #\newline)))))))
    (lambda (lib)
      (member lib libs))))

(define (filter-dependencies inputs)
  (let* ((deps (cadadr inputs))
	 (new-deps (remove (lambda (dep) (emacs-standard-library? (substring (car dep) (string-length "emacs-")))) deps)))
    (list 'propagated-inputs (list 'quasiquote new-deps))))

(define (valid-source? source)
  (let* ((sha256 (assq-ref (cdar source) 'sha256))
	 (base32 (cadar sha256)))
    (not (equal? base32 "failed to download package"))))

(define (limit-description description)
  (let ((splitted (string-split (second description) #\newline)))
    `(description ,(string-join (take splitted (min 10 (length splitted))) "\n"))))

(define (fetch-archive url)
  "Fetch archive.json from the melpa URL. The data will automatically be converted to scheme form."
  (let* ((port (http-fetch/cached (string->uri url)
				  #:ttl (* 6 3600)))
	 (data (json->scm port)))
    (close-port port)
    data))

(define (archive-version->string ver)
  "Convert VER to a string like 0.1.2. VER must be a vector."
  (if (vector? ver)
      (let* ((ver-list (vector->list ver))
	     (state (number->string (car ver-list)))
	     (rest (cdr ver-list)))
	(fold (lambda (val state) (string-append state "." (number->string val)))
	      state
	      rest))
      #f))

(define (archive-entry->package archive-entry)
  "Fetch ARCHIVE to produce a Guix package."
  (let ((name (archive-name archive-entry))
	(version (archive-version archive-entry)))
    (with-silent-out
     (lambda ()
       (let* ((package (elpa->guix-package (archive-raw-name archive-entry) #:repo 'melpa #:version version))
	      (pkg-content (cdr package))
	      (propagated-inputs-idx (list-car-index 'propagated-inputs pkg-content))
	      (description-idx (list-car-index 'description pkg-content))
	      (source (assq-ref pkg-content 'source)))
	 (if (not (valid-source? source))
	     (error (format #false "invalid source for package ~a" name)))
	 (if propagated-inputs-idx
	     (list-set! pkg-content
			propagated-inputs-idx
			(filter-dependencies (list-ref pkg-content propagated-inputs-idx))))
	 (if description-idx
	     (list-set! pkg-content
			description-idx
			(limit-description (list-ref pkg-content description-idx))))
	 package)))))

(define (archive-entry->package-scm archive-entry)
  (let ((package-name (archive-name archive-entry)))
    (catch #t
      (lambda ()
	(let ((package (archive-entry->package archive-entry)))
	  (list package-name `(define-public ,(string->symbol (string-append "emacs-" package-name)) ,package))))
      (lambda* (#:rest rest)
	(format #t "ignoring package ~a~%~a~%" package-name rest)
	#f))))

(define (newline-rewriting-port output)
  "Return an output port that rewrites strings containing the \\n escape
to an actual newline.  This works around the behavior of `pretty-print'
and `write', which output these as \\n instead of actual newlines,
whereas we want the `description' field to contain actual newlines
rather than \\n."
  (define (write-string str)
    (let loop ((chars (string->list str)))
      (match chars
        (()
         #t)
        ((#\\ #\n rest ...)
         (newline output)
         (loop rest))
        ((chr rest ...)
         (write-char chr output)
         (loop rest)))))

  (make-soft-port (vector (cut write-char <>)
                          write-string
                          (lambda _ #t)	; flush
                          #f
                          (lambda _ #t)	; close
                          #f)
                  "w"))



(define ignore-archive?
  (let ((archives '("all-ext")))
    (lambda (archive)
      (member (first archive) archives))))

(define emacs-xyz-module (resolve-module '(gnu packages emacs-xyz)))

(define (resolve-archive package-name resolved-entries final-entries)
  (let ((handle (hash-get-handle resolved-entries package-name))
	(entry (hash-ref final-entries package-name)))
    (if (not handle)
	(if entry
	    (let loop ((deps (archive-deps entry)))
	      (match deps
		((dep rest ...)
		 (if (or (resolve-archive dep resolved-entries final-entries)
			 (module-variable emacs-xyz-module (string->symbol (string-append "emacs-" dep))))
		     (loop rest)
		     (begin
		       (hash-set! resolved-entries package-name #f)
		       (hash-remove! final-entries package-name)
		       #f)))
		(()
		 (hash-set! resolved-entries package-name entry)
		 entry)))
	    #f)
	(cdr handle))))

(define (filter-archive archive)
  (let ((entries (make-hash-table)))
    (for-each (lambda (entry)
		(let* ((raw-name (car entry))
		       (name (string-downcase raw-name))
		       (rest (cdr entry))
		       (version (archive-version->string (cdr (assoc "ver" rest))))
		       (deps  (cdr (assoc "deps" rest))))
		  (hash-set! entries name
			     (make-archive name raw-name version
					   (if (eq? deps 'null)
					       '()
					       (map (compose string-downcase car) deps))))))
	      archive)
    (hash-for-each (lambda (key value)
		     (set-archive-deps! value (remove emacs-standard-library? (archive-deps value))))
		   entries)
    (let ((resolved-entries (make-hash-table)))
      (hash-for-each (lambda (key value) (resolve-archive key resolved-entries entries)) entries))
    (sort (hash-map->list (lambda (key value) value) entries)
	  (lambda (y x)
	    (string<? (archive-name y) (archive-name x))))))

(define (main args)
  (mkdir-p "emacs/packages")
  (let* ((archive (filter-archive (remove ignore-archive? (fetch-archive "https://melpa.org/archive.json"))))
	 (archive-count (length archive))
	 (i 0)
	 (out (newline-rewriting-port (open-output-file "emacs/packages/melpa.scm"))))
    (pretty-print '(define-module (emacs packages melpa)
		     #:use-module (guix build-system emacs)
		     #:use-module (guix download)
		     #:use-module (guix packages)
		     #:use-module (gnu packages emacs-xyz))
		  out)
    (display "\n" out)
    (pretty-print '(module-use-interfaces! (current-module) (module-uses (resolve-module '(gnu packages emacs-xyz)))) out)
    (display "\n" out)
    (n-for-each-par-map
     (current-processor-count)
     (lambda (entry)
       (if entry
	   (let ((name (first entry))
		 (scm (second entry)))
	     (set! i (+ i 1))
	     (format #t "[~a/~a] Creating ~a package...~%" i archive-count name)
	     (begin (pretty-print scm out)
		    (display "\n" out)))))
     archive-entry->package-scm archive)
    (close-port out)
    (display "Done!")))
