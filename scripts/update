#!/bin/sh
exec guile --no-auto-compile -e '(@ (scripts update) main)' -s "$0" "$@"
!#

(define-module (scripts update)
  #:use-module (guile)
  #:use-module (guix build utils)
  #:use-module (guix http-client)
  #:use-module (guix import elpa)
  #:use-module (guix packages)
  #:use-module (ice-9 match)
  #:use-module (ice-9 pretty-print)
  #:use-module (ice-9 threads)
  #:use-module (json)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-11)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-43)
  #:use-module (web uri)
  #:export (main))

(define (with-silent-out thunk)
  (let ((void-port (%make-void-port "w"))
	(result #f))
    (with-output-to-port void-port
      (lambda ()
	(with-error-to-port void-port
	  (lambda ()
	    (set! result (thunk))))))
    (close-port void-port)
    result))

(define emacs-standard-library?
  (let ((libs '("emacs-flymake" "emacs-seq")))
    (lambda (lib)
      (member lib libs))))

(define (filter-dependencies inputs)
  (let* ((deps (cadadr inputs))
	 (new-deps (remove (lambda (dep) (emacs-standard-library? (car dep))) deps)))
    (list 'propagated-inputs (list 'quasiquote new-deps))))

(define (fetch-archive url)
  "Fetch archive.json from the melpa URL. The data will automatically be converted to scheme form."
  (let* ((port (http-fetch/cached (string->uri url)
				  #:ttl (* 6 3600)))
	 (data (json->scm port)))
    (close-port port)
    data))

(define (archive-version->string ver)
  "Convert VER to a string like 0.1.2. VER must be a vector."
  (if (vector? ver)
      (let* ((ver-list (vector->list ver))
	     (state (number->string (car ver-list)))
	     (rest (cdr ver-list)))
	(fold (lambda (val state) (string-append state "." (number->string val)))
	      state
	      rest))
      #f))

(define (archive->package archive)
  "Fetch ARCHIVE to produce a Guix package. "
  (match archive
    ((name rest ...)
     (let ((version (archive-version->string
		     (cdr (assoc "ver" rest)))))
       (with-silent-out
	(lambda ()
	  (let* ((package (elpa->guix-package name #:repo 'melpa #:version version))
		 (pkg-content (cdr package))
		 (propagated-inputs-idx (list-index (lambda (a) (eq? (car a) 'propagated-inputs)) pkg-content)))
	    (if propagated-inputs-idx
		(list-set! pkg-content
			   propagated-inputs-idx
			   (filter-dependencies (list-ref pkg-content propagated-inputs-idx))))
	    package)))))
    (_ #f)))

(define (archive->package-scm archive)
  (let ((package-name (string-append "emacs-" (car archive))))
    (format #t "Fetching ~a...~%" package-name)
    (catch #t
      (lambda ()
	(let ((package (archive->package archive)))
	  `(define-public ,(string->symbol package-name) ,package)))
      (lambda _
	(format #t "ignoring package ~a~%" package-name)
	#f))))

(define (newline-rewriting-port output)
  "Return an output port that rewrites strings containing the \\n escape
to an actual newline.  This works around the behavior of `pretty-print'
and `write', which output these as \\n instead of actual newlines,
whereas we want the `description' field to contain actual newlines
rather than \\n."
  (define (write-string str)
    (let loop ((chars (string->list str)))
      (match chars
        (()
         #t)
	((#\\ #\n)
	 #t)
        ((#\\ #\n rest ...)
         (newline output)
         (loop rest))
        ((chr rest ...)
         (write-char chr output)
         (loop rest)))))

  (make-soft-port (vector (cut write-char <>)
                          write-string
                          (lambda _ #t)	; flush
                          #f
                          (lambda _ #t)	; close
                          #f)
                  "w"))

(define (main args)
  (mkdir-p "emacs/packages")
  (let ((archives (reverse (fetch-archive "https://melpa.org/archive.json")))
	(out (newline-rewriting-port (open-output-file "emacs/packages/melpa.scm"))))
    (pretty-print '(define-module (emacs packages melpa)
		     #:use-module (guix build-system emacs)
		     #:use-module (guix download)
		     #:use-module (guix packages)
		     #:use-module (gnu packages emacs-xyz))
		  out)
    (display "\n" out)
    (n-for-each-par-map
     (current-processor-count)
     (lambda (scm)
       (if scm
	   (begin (pretty-print scm out)
		  (display "\n" out))))
     archive->package-scm archives)
    (close-port out)
    (display "Done!")))
